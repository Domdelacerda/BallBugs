using JetBrains.Annotations;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Projectile : MonoBehaviour
{
    // The speed of the projectile the moment it is fired
    public float speed = 10f;

    // The maximum amount of damage that this projectile can deal
    public int maxDamage = 25;
    // The maximum amount of damage that this projectile can deal
    public int minDamage = 1;
    // The damage dealt per consecutive hit
    public int comboDamage = 0;
    // The amount of times that a projectile can bounce off terrain before it is destroyed
    public int bounces = 0;
    // The number of projectiles fired per shot
    public int numProjectiles = 1;

    // The amount of invincibility time in seconds that this projectile gives
    public float invincibilityTime = 0f;
    // The lifetime of the projectile (if limited life is enabled)
    public float lifetime = 1f;

    // The rigidbody component of this projectile
    public Rigidbody2D rb;

    // The bug that fired this projectile A.K.A the bug who won't be damaged by it
    public GameObject owner;

    // The game object that will be instantiated as a result of this projectile
    public GameObject secondaryEffectPrefab;
    // The base size of the secondary effect generated
    public float secondaryEffectSize = 1f;
    // Whether the secondary effect is generated by the projectile or not
    public bool generateSecondaryEffect = true;
    // Whether the projectile grants invincibility or not
    public bool invincibility = true;
    // Whether or not the projectile has limited life or not
    public bool limitedLife = false;
    // Whether or not the projectile has fixed trajectory or not
    public bool fixedTrajectory = false;

    // The player layer int represents the layer that all player characters exist on
    protected const int playerLayer = 9;
    // The enemy layer int represents the layer that all enemy characters exist on
    protected const int enemyLayer = 10;
    // The shield layer int represents the layer that all shields exist on
    protected const int shieldLayer = 11;

    // Start is called before the first frame update
    void Start()
    {
        // Ignore collisions between the bug that fired the projectile and the projectile itself
        Physics2D.IgnoreCollision(owner.GetComponent<CircleCollider2D>(), gameObject.GetComponent<Collider2D>());
        FriendlyFireOff();
        // Limited projectile life code
        if (limitedLife == true)
        {
            Destroy(gameObject, lifetime);
        }
        if (fixedTrajectory == true)
        {
            rb.velocity = transform.up * speed;
        }
        // Slinghsot mode uses data from 3 frames before the joystick recentered itself
        else if (owner.GetComponent<Bug>().slingshotMode == true)
        {
            rb.velocity = transform.up * speed * owner.GetComponent<Bug>().joystickDrawSaveStates[2].magnitude;
        }
        // Manual mode uses data from 1 frame before the joystick recentered itself
        else
        {
            rb.velocity = transform.up * speed * owner.GetComponent<Bug>().joystickDrawSaveStates[0].magnitude;
        }
        if (numProjectiles > 1)
        {
            owner.GetComponent<Bug>().currentCharge -= 1f / (numProjectiles - 1);
        }
        else if (numProjectiles == 1)
        {
            owner.GetComponent<Bug>().currentCharge = 0;
        }
    }

    public void ShieldDeflect(Transform other, float speed)
    {
        Vector3 direction = new Vector3(owner.transform.position.x - other.position.x,
            owner.transform.position.y - other.position.y, owner.transform.position.z - other.position.z);
        rb.velocity = direction.normalized * speed * 1.5f;
    }

    public void FriendlyFireOff()
    {
        if (owner.layer == enemyLayer)
        {
            GameObject[] players = GameObject.FindGameObjectsWithTag("Bug");
            for (int i = 0; i < players.Length; i++)
            {
                if (players[i].layer == enemyLayer)
                {
                    Physics2D.IgnoreCollision(players[i].GetComponent<CircleCollider2D>(), gameObject.GetComponent<Collider2D>());
                }
            }
        }
    }

    void OnCollisionEnter2D(Collision2D collision)
    {
        // On collision with terrain
        if (collision.gameObject.CompareTag("Terrain"))
        {
            bounces--;
        }
        // On collision with a shield
        else if (collision.collider.gameObject.layer == shieldLayer)
        {
            // Shield script here
            ShieldDeflect(collision.collider.transform, collision.relativeVelocity.magnitude);
            // Reactivate collision between the bug that initially fired the projectile and the projectile itself
            Physics2D.IgnoreCollision(owner.GetComponent<CircleCollider2D>(), gameObject.GetComponent<Collider2D>(), false);
            owner = collision.gameObject;
            int damage = maxDamage + comboDamage * owner.GetComponent<Bug>().comboCounter;
            owner.GetComponent<Bug>().Shield(damage);
            if (invincibility == true)
            {
                collision.gameObject.GetComponent<Bug>().InvincibilityFrames(invincibilityTime);
            }
        }
        // On collision with a player
        else if (collision.gameObject.layer == playerLayer || collision.gameObject.layer == enemyLayer)
        {
            int damage = maxDamage + comboDamage * owner.GetComponent<Bug>().comboCounter;
            collision.gameObject.GetComponent<Bug>().Damage(damage);
            if (invincibility == true)
            {
                collision.gameObject.GetComponent<Bug>().InvincibilityFrames(invincibilityTime);
            }
            owner.GetComponent<Bug>().comboCounter++;
            Destroy(gameObject);
        }
    }

    void FixedUpdate()
    {
        // The projectile will rotate in the direction that it is facing
        rb.rotation = Mathf.Atan2(rb.velocity.x, rb.velocity.y) * Mathf.Rad2Deg * -1f;
        // Velocity is clamped so that the projectile never moves too fast
        rb.velocity = Vector2.ClampMagnitude(rb.velocity, speed);
        // When the projectile runs out of bounces, it disappears
        if (generateSecondaryEffect == false || secondaryEffectPrefab == null)
        {
            if (bounces < 0)
            {
                Destroy(gameObject);
            }
        }
    }
}